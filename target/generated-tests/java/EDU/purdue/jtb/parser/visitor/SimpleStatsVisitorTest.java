/* Generated by JTB 1.x.y from visitor/SimpleStatsVisitorTest.ftl */
package EDU.purdue.jtb.parser.visitor;

import static EDU.purdue.jtb.parser.syntaxtree.JTBNodesConstantsTest.*;
import EDU.purdue.jtb.parser.syntaxtree.*;

import java.util.Hashtable;
import java.util.Map;

/**
 * Provides default methods which visit each node in the tree in depth-first order.<br>
 * In your "Void" visitors extend this class and override part or all of these methods.
 */
public class SimpleStatsVisitorTest extends DepthFirstVoidVisitorTest {

  /*
   * Statistics
   */
 
  /** The Integer 0 */
  static final Integer ZERO = Integer.valueOf(0);
 /** Productions (JTB user nodes) counters map */
  static final Map<String, Integer> prodNameMap = new Hashtable<String, Integer>(NB_JTB_USER_NODES);
  /** Initialize the map */
  static {
    for (int i = 0; i < NB_JTB_USER_NODES; i++) {
      prodNameMap.put(JTB_USER_NODE_NAME[i], ZERO);
    }
  }

  /**
   * Adds a production name to its maps.
   *
   * @param aINode - the JTB INode
   */
  static void addProduction(final INode aINode) {
    final String cn = aINode.getClass().getName();
    final String name = cn.substring(1 + cn.lastIndexOf('.'));
    synchronized (prodNameMap) {
      Integer val = prodNameMap.get(name);
      val = Integer.valueOf(1 + val.intValue());
      prodNameMap.put(name, val);
    }
  }

  /**
   * Prints on System.out productions counters (lines of name:value).
   */
  public static void printProdStats() {
    for (int i = 0; i < NB_JTB_USER_NODES; i++) {
      final String name = JTB_USER_NODE_NAME[i];
      final Integer val = prodNameMap.get(name);
      System.out.println(name + ":" + val.toString());
    }
  }
  

  /*
   * Base nodes classes visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link NodeChoice} node.
   *
   * @param n - the node to visit
   */
  @Override
  public void visit(final NodeChoice n) {
    super.visit(n);
  }

  /**
   * Visits a {@link NodeList} node.
   *
   * @param n - the node to visit
   */
  @Override
  public void visit(final NodeList n) {
    super.visit(n);
  }

  /**
   * Visits a {@link NodeToken} node.
   *
   * @param n - the node to visit
   */
  @Override
  public void visit(final NodeToken n) {
    super.visit(n);
  }


  /*
   * User grammar generated visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link CompilationUnit} node, whose children are the following :
   * <p>
   * f0 -> ( %0 < IDENTIFIER ><br>
   * .. .. | %1 "LOOKAHEAD"<br>
   * f1 -> "="<br>
   *
   * @param n - the node to visit
   */
  @Override
  public void visit(final CompilationUnit n) {
    addProduction(n);
    super.visit(n);
  }

  /**
   * Visits a {@link Expression} node, whose children are the following :
   * <p>
   * f0 -> [ #0 "options" #1 "{"<br>
   * .. .. . #2 ( OptionBinding() )*<br>
   *
   * @param n - the node to visit
   */
  @Override
  public void visit(final Expression n) {
    addProduction(n);
    super.visit(n);
  }

  /**
   * Visits a {@link IdentifierAsString} node, whose children are the following :
   * <p>
   * f0 -> JavaCCOptions()<br>
   * f1 -> "PARSER_BEGIN"<br>
   * f1 -> "="<br>
   *
   * @param n - the node to visit
   */
  @Override
  public void visit(final IdentifierAsString n) {
    addProduction(n);
    super.visit(n);
  }

}