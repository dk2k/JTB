/* Generated by JTB 1.5.1 */
/* A small grammar for testing:
 * - a bunch of JTB options not present in jtbgram.jtb
 */
options
{
  STATIC = false;
  // (default false)
  IGNORE_CASE = true;
  // (default false)
  //  DEBUG_PARSER = true; // (default false)
  // Relative path of Java files generated by JavaCC from the JJ file
  OUTPUT_DIRECTORY = "../../../../../target/generated-tests/jj/grammars/a";
  TOKEN_FACTORY = "SmallGrammar";
  // JTB_O = "../../../../../target/generated-tests/jtb/grammars/a/SmallGrammar.jj";
  // out file (default jtb.out.jj)
  // JTB_CHM = true;
  // children methods (default false)
  // JTB_CL = true;
  // classes list (default false)
  // JTB_DL = true;
  // depth level (default false)
  //JTB_EG = "EDU.purdue.jtb.freemarker.egt.ExternalGeneratorTester"; // need new plugin with classpath
  // JTB_F = true;
  // descriptive fields (default false)
  // JTB_HK = true;
  // hook (default false)
  // JTB_HKD = "../../../../../target/generated-tests/jtb/grammars/a/sghook";
  // JTB_HKP = "grammars.a.sghook";
  //  JTB_IA = true; // inline accepts (default false)
  //  JTB_JD = true; // javadoc comments (default false)
  // JTB_ND = "../../../../../target/generated-tests/jtb/grammars/a/sgtree";
  // JTB_NP = "grammars.a.sgtree";
  // JTB_NOPLG = true;
  // no parallel user nodes generation (default false)
  // JTB_NOSIG = true;
  // no signature (default false)
  // JTB_NPFX = "AST";
  // nodes prefix
  // JTB_NSFX = "123";
  // nodes suffix
  // JTB_PP = true;
  // parent pointers (default false)
  // JTB_PRINTER = true;
  // dumper & formatter (default false) (TreeFormatter.java not overwritten!)
  // JTB_TK = true;
  // special tokens (default false)
  // JTB_TKJJ = true;
  // special tokens (default false)
  // JTB_VIS = "Void,void,None;Vis2,R,A,int[],short...";
  // first needed for dumper and formatter, second for tests
  // JTB_VD = "../../../../../target/generated-tests/jtb/grammars/a/sgvis";
  // JTB_VP = "grammars.a.sgvis";
  // JTB_W = true;
// no overwrite (default false)
}

PARSER_BEGIN(SmallGrammar)
package grammars.a;

import grammars.a.sgvis.*;
import grammars.a.sghook.*;
// not needed, just for code coverage
import grammars.a.sgtree.*;
// not needed, just for code coverage
import java.util.ArrayList;


public class SmallGrammar {

  /** The hook for enter / exit node scope hook methods (to be instantiated) */
  public IEnterExitHook jtb_eeh;


  /* --- JTB generated return variables declarations --- */

  /** Return variable for the {@link #bp_jual} BNFProduction) */
  java.util.ArrayList<Float> jtbrt_bp_jual;

  /** Return variable for the {@link #bp_hm} BNFProduction) */
  java.util.HashMap<String, Float> jtbrt_bp_hm;

  /** Return variable for the {@link #jc_0} JavaCodeProduction) */
  int jtbrt_jc_0;

  /* --- User code --- */

  public static void main(String args[]) {
    System.err.flush();
    System.out.println("SmallGrammar Reading ...");
    SmallGrammar sg = new SmallGrammar(System.in);
    try {
      sg.jtb_eeh = new FancyEnterExitHook(sg, "blabla");
      System.out.println("... Parsing with fancy hook...");
      ASTclassDeclaration123 cd = sg.ASTclassDeclaration123();
      DepthFirstVoidVisitor v = new DepthFirstVoidVisitor();
      System.out.println("... Visiting...");
      cd.accept(v);
      System.out.println();
      System.out.println("... Dumping tree...");
      TreeDumper d = new TreeDumper();
      cd.accept(d);
      TreeFormatter f = new TreeFormatter();
      System.out.println();
      System.out.println("... Formatting tree...");
      cd.accept(f);
      FancyVisitor fv = new FancyVisitor();
      System.out.println("... Fancy visiting...");
      String res = cd.accept(fv, "", new int[]{  }, (short)0);
      System.out.println(res);
      System.out.println("SmallGrammar ended.");
      System.exit(0);
    }
    catch (final Exception e) {
      System.out.flush();
      System.err.println("Oops!");
      System.err.println(e.getMessage());
      System.exit(-1);
    }
  }

  /* For test case with user changed factory method */
  /**
   * Factory method used by JavaCC to create a new Token object, which will be a (JTB) subclassed NodeToken object.
   *
   * @param ofKind - the token kind
   * @param image - the token image
   *
   * @return a new Token (which is also a NodeToken)
   */
  public static Token newToken(int ofKind, String image) {
    return new NodeToken(ofKind, image);
  }
}

PARSER_END(SmallGrammar)

ASTclassDeclaration123 ASTclassDeclaration123() :
{
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  ASTclassName123 n2 = null;
  NodeToken n3 = null;
  Token n4 = null;
  NodeListOptional n5 = new NodeListOptional();
  NodeChoice n6 = null;
  NodeSequence n7 = null;
  ASTmethod123 n8 = null;
  NodeSequence n9 = null;
  ASTinstruction123 n10 = null;
  NodeToken n11 = null;
  Token n12 = null;
  NodeToken n13 = null;
  Token n14 = null;
  ASTjc_0123 n15 = null;
  NodeToken n16 = null;
  Token n17 = null;
  ASTclassDeclaration123 jtbNode = null;
}
{
  // --- user BNFProduction ExpansionChoices ---
  { if (jtb_eeh != null) jtb_eeh.ASTclassDeclaration123Enter(); }
  n1 = "class"
  { n0 = (NodeToken) n1; }
  n2 = ASTclassName123()
  n4 = "{"
  { n3 = (NodeToken) n4; }
  (
    (
      LOOKAHEAD( 2 )
      { n7 = new NodeSequence(1); }
      n8 = ASTmethod123()
      { n7.addNode(n8); }
      { n6 = new NodeChoice(n7, 0, 2); }
    |
      { n9 = new NodeSequence(1); }
      n10 = ASTinstruction123()
      { n9.addNode(n10); }
      { n6 = new NodeChoice(n9, 1, 2); }
    )
    { n5.addNode(n6); }
  )*
  { n5.nodes.trimToSize(); }
  n12 = "}"
  { n11 = (NodeToken) n12; }
  n14 = "."
  { n13 = (NodeToken) n14; }
  n15 = ASTjc_0123()
    n17 = < EOF >
  { n17.beginColumn++; }
  { n17.endColumn++; }
  { n16 = (NodeToken) n17; }
  { jtbNode = new ASTclassDeclaration123(n0, n2, n3, n5, n11, n13, n15, n16); }
  { if (jtb_eeh != null) jtb_eeh.ASTclassDeclaration123Exit(jtbNode); }
  { return jtbNode; }
}

ASTclassName123 ASTclassName123() :
{
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  ASTclassName123 jtbNode = null;
  // --- user BNFProduction java block ---
  // leave b & e uninitialized
  char b, e;
  Token t = null;
}
{
  // --- user BNFProduction ExpansionChoices ---
  { if (jtb_eeh != null) jtb_eeh.ASTclassName123Enter(); }
  n1 = < ID >
  { n0 = (NodeToken) n1; }
  { t = n1; }
  {
    //    e = 'Ã©';
    b = '\b';
  }
  { jtbNode = new ASTclassName123(n0); }
  { if (jtb_eeh != null) jtb_eeh.ASTclassName123Exit(jtbNode); }
  { return jtbNode; }
}

ASTmethod123 ASTmethod123() :
{
  // --- JTB generated node declarations ---
  ASTmethodName123 n0 = null;
  NodeToken n1 = null;
  Token n2 = null;
  NodeList n3 = new NodeList();
  NodeSequence n4 = null;
  ASTinstruction123 n5 = null;
  NodeToken n6 = null;
  Token n7 = null;
  ASTmethod123 jtbNode = null;
}
{
  // --- user BNFProduction ExpansionChoices ---
  { if (jtb_eeh != null) jtb_eeh.ASTmethod123Enter(); }
  n0 = ASTmethodName123()
  n2 = "("
  { n1 = (NodeToken) n2; }
  (
    { n4 = new NodeSequence(1); }
    n5 = ASTinstruction123()
    { n4.addNode(n5); }
    { n3.addNode(n4); }
  )+
  { n3.nodes.trimToSize(); }
  n7 = ")"
  { n6 = (NodeToken) n7; }
  { jtbNode = new ASTmethod123(n0, n1, n3, n6); }
  { if (jtb_eeh != null) jtb_eeh.ASTmethod123Exit(jtbNode); }
  { return jtbNode; }
}

ASTmethodName123 ASTmethodName123() :
{
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  ASTmethodName123 jtbNode = null;
}
{
  // --- user BNFProduction ExpansionChoices ---
  { if (jtb_eeh != null) jtb_eeh.ASTmethodName123Enter(); }
  /*com*/ n1 = < ID >
  { n0 = (NodeToken) n1; }
  { jtbNode = new ASTmethodName123(n0); }
  { if (jtb_eeh != null) jtb_eeh.ASTmethodName123Exit(jtbNode); }
  { return jtbNode; }
/*com*/
 // for code coverage lastCharIsSpace false
}

ASTinstruction123 ASTinstruction123() :
{
  // --- JTB generated node declarations ---
  NodeChoice n0 = null;
  NodeSequence n1 = null;
  NodeToken n2 = null;
  Token n3 = null;
  NodeToken n4 = null;
  Token n5 = null;
  NodeSequence n6 = null;
  NodeToken n7 = null;
  Token n8 = null;
  ASTinstruction123 jtbNode = null;
}
{
  // --- user BNFProduction ExpansionChoices ---
  { if (jtb_eeh != null) jtb_eeh.ASTinstruction123Enter(); }
  (
    LOOKAHEAD( 2 )
    { n1 = new NodeSequence(2); }
    n3 = < ID >
    { n2 = (NodeToken) n3; }
    { n1.addNode(n2); }
    n5 = ";"
    { n4 = (NodeToken) n5; }
    { n1.addNode(n4); }
    { n0 = new NodeChoice(n1, 0, 2); }
  |
    { n6 = new NodeSequence(1); }
    bp_al()
    n8 = ","
    { n7 = (NodeToken) n8; }
    { n6.addNode(n7); }
    { n0 = new NodeChoice(n6, 1, 2); }
  )
  { jtbNode = new ASTinstruction123(n0); }
  { if (jtb_eeh != null) jtb_eeh.ASTinstruction123Exit(jtbNode); }
  { return jtbNode; }
}

TOKEN :
{
  < A_BS_B : "a\bb" >
| < ES : "\u00e9\u00e8\u00ea" >
| < SYN_ESC : "\u0016\u001b" >
| < ID : ( ["a"-"z", "A"-"Z", "0"-"9"] )+ >
}

SKIP :
{
  < WS : 
    (
      " "
    | "\t"
    | "\n"
    | "\r"
    ) >
}

ArrayList<Float> bp_al () /*!*/ :
{
  ArrayList<Float> al = new ArrayList<>();
  java.util.ArrayList<Float> jual = null;
}
{
  < ID >
  {
    al.add(-23.E-40F);
    jual = new java.util.ArrayList<>(al);
    jual.add(.12e+30F);
    return jual;
  }
}

ASTbp_jual123 ASTbp_jual123() :
{
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  ASTbp_jual123 jtbNode = null;
  // --- user BNFProduction java block ---
  ArrayList<Float> al = new ArrayList<>();
  java.util.ArrayList<Float> jual = null;
}
{
  // --- user BNFProduction ExpansionChoices ---
  { if (jtb_eeh != null) jtb_eeh.ASTbp_jual123Enter(); }
  n1 = < ID >
  { n0 = (NodeToken) n1; }
  { jtbNode = new ASTbp_jual123(n0); }
  {
    al.add(-23.E-40F);
    jual = new java.util.ArrayList<>(al);
    jual.add(.12e+30F);
    jtbrt_bp_jual = jual;
  }
  { if (jtb_eeh != null) jtb_eeh.ASTbp_jual123Exit(jtbNode); }
  { return jtbNode; }
}

ASTbp_hm123 ASTbp_hm123(final java.util.ArrayList<Float> jual) :
{
  // --- JTB generated node declarations ---
  NodeToken n0 = null;
  Token n1 = null;
  ASTbp_hm123 jtbNode = null;
  // --- user BNFProduction java block ---
  java.util.HashMap<String , Float> hm = new java.util.HashMap<>();
}
{
  // --- user BNFProduction ExpansionChoices ---
  { if (jtb_eeh != null) jtb_eeh.ASTbp_hm123Enter(); }
  n1 = < ID >
  { n0 = (NodeToken) n1; }
  { jtbNode = new ASTbp_hm123(n0); }
  {
    hm.put("nine", jual == null ? 9.9F : jual.get(9));
    jtbrt_bp_hm = hm;
  }
  { if (jtb_eeh != null) jtb_eeh.ASTbp_hm123Exit(jtbNode); }
  { return jtbNode; }
}

// for coverage TODO voir tests avec hook
JAVACODE ASTjc_0123 ASTjc_0123() /*%*/ 
{
  if (jtb_eeh != null) jtb_eeh.ASTjc_0123Enter();
  int i = 0;jtbrt_jc_0 = i;
  ASTjc_0123 jtbNode = new ASTjc_0123();
  if (jtb_eeh != null) jtb_eeh.ASTjc_0123Exit(jtbNode);
  return jtbNode;
}

