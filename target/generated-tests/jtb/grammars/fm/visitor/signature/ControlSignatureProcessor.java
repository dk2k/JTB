/* Generated by JTB 1.5.1 */
package grammars.fm.visitor.signature;

import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;

import grammars.fm.syntaxtree.NodeConstants;

@SuppressWarnings("javadoc")
@SupportedAnnotationTypes("grammars.fm.visitor.signature.NodeFieldsSignature")
// Adapt the release to your compiler level
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class ControlSignatureProcessor extends AbstractProcessor {

  public ControlSignatureProcessor() {
    super();
  }

    @Override
    public boolean process(@SuppressWarnings("unused") final Set<? extends TypeElement> annotations,
                           final RoundEnvironment roundEnv) {
      for (final Element elem : roundEnv.getElementsAnnotatedWith(NodeFieldsSignature.class)) {
        final NodeFieldsSignature nfs = elem.getAnnotation(NodeFieldsSignature.class);
        final int osig = nfs.value()[0];
        final int nsig = nfs.value()[1];
        final int nix = nfs.value()[2];
        if (osig != nsig) {
          final String message = "Different node fields signatures (old=" + nfs.value()[0] + ", new=" +
                                 nfs.value()[1] + ") in grammars.fm.visitor." +
                                 elem.getEnclosingElement().getSimpleName() + "#" +
                                 elem.getSimpleName() + "(final " +
                                 NodeConstants.JTB_USER_NODE_NAME[nix] + " n)";
          processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, message);
        }
      }
      return true; // no further processing of this annotation type
    }

  }
