/* A small grammar for testing -eg / JTB_EG JTB option not present in jtbgram.jtb */
options
{
  STATIC = false; // (default true)
  IGNORE_CASE = true; // (default false)
  //  DEBUG_PARSER = true; // (default false)
  // Relative path of Java files generated by JavaCC from the JJ file
  OUTPUT_DIRECTORY = "../../../../../target/generated-tests/jj/grammars/fm";

  JTB_D = "../../../../../target/generated-tests/jtb/grammars/fm";
  JTB_P = "grammars.fm";
  JTB_O = "../../../../../target/generated-tests/jtb/grammars/fm/EGTGrammar.jj"; // out file (default jtb.out.jj)
  JTB_EG = "EDU.purdue.jtb.freemarker.egt.ExternalGeneratorTester"; // need new JavaCC Eclipse plugin with classpath
  JTB_VIS = "Void,void,None;Vis2,int,java.lang.String"; // first needed for dumper and formatter, second for tests
  JTB_TK = true; // special tokens (default true)
  JTB_TKJJ = true; // special tokens (default true)
  JTB_JD = false; // javadoc comments (default true)
}

PARSER_BEGIN(EGTGrammar)
package grammars.fm;

import grammars.fm.visitor.*;

public class EGTGrammar
{
  public static void main(String args [])
  {
    System.err.flush();
    System.out.println("EGTGrammar Reading...");
    EGTGrammar egtg = new EGTGrammar(System.in);
    try
    {
      System.out.println("... Parsing...");
      classDeclaration cd = egtg.classDeclaration();
      IVis2Visitor v = new DepthFirstVis2Visitor();
      System.out.println("... Visiting...");
      int rc = cd.accept(v, "  ");
      System.out.println("EGTGrammar ended.");
      System.exit(0);
    }
    catch (final Exception e)
    {
      System.out.flush();
      System.err.println("Oops!");
      System.err.println(e.getMessage());
      System.exit(-1);
    }
  }
}

PARSER_END(EGTGrammar)

void classDeclaration() :
{}
{
  skip() 
  "class" 
  className() !
  "{"
  (
    method()
  )*
  "}" 
  "." < EOF >
}

void className() :
{
  // leave b uninitialized (for code coverage)
  char b, e = '\u0000';
}
{
  < ID >
  {
    b = '\b';
//    e = 'é';
  }
}

void method() :
{}
{
  methodName() 
  "("
  (
    instruction()
  )+
  ")"
}

void methodName() :
{}
{
  < ID >
}

void instruction() :
{}
{
  < ID > ";"
}

JAVACODE void skip() %
{
  Token tk = getNextToken();
}

TOKEN :
{
  < A_BS_B : "a\bb" >
| < ES : "éèê" >
| < SYN_ESC : "\u0016\u001b" >
| < ID : ([ "a"-"z", "A"-"Z", "0"-"9" ])+ >
}

SKIP :
{
  < WS :
    (
      " "
    | "\t"
    | "\n"
    | "\r"
    ) >
}
