/* A small grammar for testing:
 * - no package declaration, a package option
 */
options
{
  STATIC = false; // (default true)
  //  DEBUG_PARSER = true; // (default false)
  // Relative path of Java files generated by JavaCC from the JJ file
  OUTPUT_DIRECTORY = "../../../../../target/generated-tests/jj/grammars/q";
  JTB_O = "../../../../../target/generated-tests/jtb/grammars/q/NoDecOptPackageGrammar.jj"; // out file (default jtb.out.jj)
  JTB_D = "../../../../../target/generated-tests/jtb/grammars/q";
  JTB_IA = true; // inline accepts (default false)
  JTB_P = "grammars.q";
}

PARSER_BEGIN(NoDecOptPackageGrammar)

import grammars.q.visitor.*;
import java.util.ArrayList;

public class NoDecOptPackageGrammar
{
  public static void main(String args [])
  {
    System.out.println("NoDecOptPackageGrammar Reading ...");
    NoDecOptPackageGrammar npg = new NoDecOptPackageGrammar(System.in);
    try
    {
      System.err.println("... Parsing...");
      classDeclaration cd = npg.classDeclaration();
      DepthFirstVoidVisitor v = new DepthFirstVoidVisitor();
      System.out.println("... Visiting...");
      cd.accept(v);
      System.out.println("NoDecOptPackageGrammar ended.");
      System.exit(0);
    }
    catch (final Exception e)
    {
      System.out.flush();
      System.err.println("Oops!");
      System.err.println(e.getMessage());
      System.exit(-1);
    }
  }

}

PARSER_END(NoDecOptPackageGrammar)

void classDeclaration() :
{}
{
  "class" 
  className() 
  "{"
  (
    LOOKAHEAD(2) 
    method()
  | 
    instruction()
  )*
  "}" 
  "."
  jc_0()
  < EOF >
}

void className() :
{
  // leave b & e uninitialized
  char b, e;
  Token t = null;
}
{
  t = < ID >
  {
    //    e = 'Ã©';
    b = '\b';
  }
}

void method() :
{}
{
  methodName()
  "("
  (
    instruction()
  )+
  ")"
}

void methodName() :
{}
{
  /*com*/< ID >/*com*/ // for code coverage lastCharIsSpace false
}

void instruction() :
{}
{
  LOOKAHEAD(2) 
  < ID > ";"
| 
  bp_al() ","
}

TOKEN :
{
  < A_BS_B : "a\bb" >
| < ES : "\u00e9\u00e8\u00ea" >
| < SYN_ESC : "\u0016\u001b" >
| < ID : ([ "a"-"z", "A"-"Z", "0"-"9" ])+ >
}

SKIP :
{
  < WS :
    (
      " "
    | "\t"
    | "\n"
    | "\r"
    ) >
}

ArrayList < Float > bp_al() !:
{
  ArrayList< Float > al = new ArrayList<>();
  java.util.ArrayList < Float > jual = null;
}
{
  < ID >
  {
    al.add(- 23.E-40F);
    jual = new java.util.ArrayList<>(al);
    jual.add(.12e+30F);
    return jual;
  }
}

java.util.ArrayList < Float > bp_jual() :
{
  ArrayList< Float > al = new ArrayList<>();
  java.util.ArrayList < Float > jual = null;
}
{
  < ID >
  {
    al.add(- 23.E-40F);
    jual = new java.util.ArrayList<>(al);
    jual.add(.12e+30F);
    return jual;
  }
}

java.util.HashMap < String, Float > bp_hm(final java.util.ArrayList < Float > jual) :
{
  java.util.HashMap < String, Float > hm = new java.util.HashMap<> ();
}
{
  < ID >
  {
    hm.put("nine", jual == null ? 9.9F : jual.get(9));
    return hm;
  }
}

// for coverage TODO voir tests avec hook
JAVACODE int jc_0() % {
  int i = 0;
  return i;
}


