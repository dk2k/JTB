/* A Full grammar for testing:
 * - all JavaCC / JTB / Java syntaxes
 * Currently designed for JavaCC 7.0 & JTB 1.5.0
 */
options
{
  STATIC = false; // (default true)
  //  DEBUG_PARSER = true; // (default false)
  // Relative path of Java files generated by JavaCC from the JJ file
  OUTPUT_DIRECTORY = "../../../../../target/generated-tests/jj/grammars/b";
  JTB_O = "../../../../../target/generated-tests/jtb/grammars/b/FullGrammar.jj"; // out file (default jtb.out.jj)
  JTB_D = "../../../../../target/generated-tests/jtb/grammars/b";
  JTB_P = "grammars.b";
  JTB_IA = true; // inline accepts (default false)
  JTB_JD = true; // javadoc comments (default false)
  JTB_NOPLG = true; // no parallel generation (default false)
}

PARSER_BEGIN(FullGrammar)
package grammars.b;
import grammars.b.visitor.*;
import java.util.ArrayList;

public class FullGrammar
{
  
  public static void main(String args [])
  {
    System.err.println("FullGrammar Reading...");
    FullGrammar fg = new FullGrammar(System.in);
    try
    {
      System.err.println("... Parsing...");
      Start st = fg.Start();
      DepthFirstVoidVisitor v = new DepthFirstVoidVisitor();
      System.err.println("... Visiting...");
      st.accept(v);
      System.err.println("... FullGrammar ended.");
      System.exit(0);
    }
    catch (final Exception e)
    {
      System.err.println("Oops!");
      System.err.println(e.getMessage());
      e.printStackTrace();
      System.exit(-1);
    }
  }

  private void info(final String aMsg) {
    String tk0 = getToken(0).toString();
    String tk1 = getToken(1).toString();
    String ct0 = tk0 == null ? "!null!" : tk0.length() == 0 ? "!empty!" : tk0;
    String ct1 = tk1 == null ? "!null!" : tk1.length() == 0 ? "!empty!" : tk1;
    System.err.println(aMsg + ", current token = " + ct0 + ", next token = " + ct1);
  }

  int global_i, global_j;
  
  boolean some_lookahead()
  {
    // some logic for lookahead
    return true;
  }
  
  void some_lexical_action()
  {
    // some logic for lexical action
    return;
  }
  
}

// for JavaCC & java code coverage
class Tuple < F, S, T > implements ITuple < F, S, T >, IL
{
  public F first, first2;

  private S second;

  protected T third;
  Tuple < Float, String, ? extends Thread > myTupleQ;

  protected java.util.List < ? extends Boolean > [] [] list = new ArrayList [1] [1];

  public void setValues(F first, S second, T third)
  {
    this.first = this.first2 = first;
    this.second = second;
    this.third = third;
  }
  @ Override 
  public F getFirst()
  {
    return this.first;
  }
  @ Override 
  public S getSecond()
  {
    return this.second;
  }

  public T getThird()
  {
    return this.third;
  }
  @ Override 
  public boolean get1stElem(java.util.List < ? extends Boolean > list)
  {
    this.list [0] [0] = list;
    return list.get(0);
  }
  Tuple()
  {
    first = first2 = null;
    second = null;
    third = null;
    list = new ArrayList [1] [1];
  }
  Tuple(F f, S s, T t)
  {
    first = first2 = null;
    second = s;
    third = t;
    list = new ArrayList [1] [1];
  }
  Tuple < F, S, T > getNewInstance()
  {
    return new Tuple < F, S, T > ();
  }
}

interface IL
{
  boolean get1stElem(java.util.List < ? extends Boolean > list);
}

interface IF < F >
{
  public F getFirst();
}

interface IS < S >
{
  abstract S getSecond();
}

interface ITuple < F, S, T > extends IF, IS
{
  // TODO add when JavaCC handles default methods
  //  default E getThird() { return third; }
  static < A extends Boolean & ITuple > boolean getAll(A a)
  {
    return true && a;
  }
}

  // for java code coverage
final class Pizza
{
  private PizzaStatus status;

  interface PSO
  {
    public boolean isOrdered();
  }

  interface PSR
  {
    public boolean isReady();
  }
  
  protected enum PizzaStatus implements PSO, PSR
  {
    ORDERED(5)
    {
      @ Override 
      public boolean isOrdered()
      {
        return true;
      }
    }
    , 
    READY(2)
    {
      @ Override 
      public boolean isReady()
      {
        return true;
      }
    }
    , 
    DELIVERED(0)
    {
      @ Override 
      public boolean isDelivered()
      {
        return true;
      }
    }
    ,
    ;

    private int timeToDelivery;

    public boolean isOrdered()
    {
      return false;
    }

    public boolean isReady()
    {
      return false;
    }

    public boolean isDelivered()
    {
      return false;
    }

    public int getTimeToDelivery()
    {
      return timeToDelivery;
    }
    
    PizzaStatus(int timeToDelivery)
    {
      this.timeToDelivery = timeToDelivery;
    }
  }

  public boolean isDeliverable()
  {
    return this.status.isReady();
  }
}

class FGclass1 {
}

class FGclass2 {
}

PARSER_END(FullGrammar)

/*
 * -----------------------------
 * Production-JavaCodeProduction
 * -----------------------------
 * Modifiers combinations checked
 * all ResultType to be checked somewhere else
 * FormalParameters checked
 * throws checked
 * all combinations with node generation indicator (%) checked
 */

JAVACODE void jcp_v()
{
}

JAVACODE void jcp_v$() %
{
  return;
}

JAVACODE private void jcp_iv(int[] i) throws IllegalStateException
{
  throw new IllegalStateException("dummy ise");
}

JAVACODE private void jcp_iv$(final int i) throws IllegalStateException %
{
  if (i == 0)
  {
    throw new IllegalStateException("dummy ise");
  }
}

// JavaCC does not accept final (but should TODO report bug#)
/*
JAVACODE final protected void jcp_fov()
{
}

JAVACODE final protected void jcp_fov$() %
{
}
*/

JAVACODE public int jcp_ui(final int i, boolean b) throws IllegalStateException, NullPointerException
{
  if (i == 0)
  {
    if (b) throw new IllegalStateException((String) null); // cast for ambiguity suppression
    else throw new NullPointerException();
  }
  return i - 1;
}

JAVACODE public int jcp_ui$(final int i, boolean b) throws IllegalStateException, NullPointerException %
{
  if (i == 0)
  {
    if (b) throw new IllegalStateException("with parameter");
    else throw new NullPointerException();
  }
  return i;
}

JAVACODE protected String jcp_s(String s)
{
  return s;
}

JAVACODE protected String[] jcp_sa(String[] sa)
{
  return sa;
}

JAVACODE protected String jcp_s$(String s) %
{
  return s + "added for expression";
}

JAVACODE public boolean[] jcp_ubar()
{
  return new boolean[1];
}

JAVACODE public boolean[] jcp_ubar$() %
{
  return new boolean[1];
}

// JavaCC handles correctly bad Modifiers combination; should JTB ?
/*
JAVACODE public protected boolean jcp_uob()
{
  return false;
}
*/

/*
 * --------------------------------
 * Production-RegularExprProduction
 * --------------------------------
 * all lexical states list forms
 * all RegExprKind checked
 * [IGNORE_CASE] checked
 * private regular expression (#) checked
 */

TOKEN [ IGNORE_CASE ] :
{
  < A_BS_B : "a\bb" >
| < ES : "\u00e9\u00e8\u00ea" >
| < #SYN_ESC : "\u0016\u001b" >
| < #ES_OR_SYN_ESC : < ES > | < SYN_ESC > >
| < abID : ([ "a"-"b", "A"-"B" ])([ "a"-"z", "A"-"Z", "0"-"9" ])* >
| < cdID$ : ([ "c"-"d", "C"-"D" ])([ "a"-"z", "A"-"Z", "0"-"9" ])* > !
| < efID : ([ "e"-"f" ])([ "A"-"Z", "0"-"9" ])* > // to see if IGNORE_CASE really works
| < ID : ([ "a"-"z", "A"-"Z" ])([ "a"-"z", "A"-"Z", "0"-"9" ])* >
| < NUM_2$ : ([ "0"-"9" ]) {2} > !
| < NUM_3_9 : ([ "0"-"9" ]) {3, 9} >
| "%ctbu?no" // %can this be used? no
| < NOT_BUILT : "%notbuilt?" > !
}

TOKEN :
{
  "%ctbu?yes" // %can this be used? yes
}

< DEFAULT >
SPECIAL_TOKEN :
{
  < SINGLE_LINE_COMMENT :
    "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
}

< * >
SKIP :
{
  < WS :
    (
      " "
    | "\t"
    | "\n"
    | "\r"
    ) >
}

MORE :
{
  "\""
  {
    stringSize = 0;
  }
  : WithinString
}

< WithinString >
TOKEN :
{
  < STRLIT : "\"" >
  {
    System.err.println("Size = " + stringSize);
  }
  : DEFAULT
}

< WithinString >
MORE :
{
  < ~[ "\n", "\r" ] >
  {
    stringSize++;
  }
}

/*
 * ----------------------------
 * Production-TokenManagerDecls
 * ----------------------------
 */
TOKEN_MGR_DECLS :
{
  int stringSize;
}

/*
 * ------------------------
 * dummy productions, for code coverage
 * Production-BNFProduction
 * $ for no node creation at bnf production level, _ for no node creation at regular expression level
 * Modifiers combinations checked
 * all ResultType checked
 * FormalParameters checked
 * throws checked
 * all combinations with node generation indicator (!) checked
 * all combinations of lookahead parameters checked
 * ------------------------
 */

void Start() :
{
  java.util.ArrayList < Float > jual = new java.util.ArrayList< Float >();
  for (int i = 0; i < 10; i++) jual.add(Float.valueOf(i));
}
// choices/sequences for grouping tests in build.xml
{
  { info("before 1st choice"); }
  < EOF >
  { info("after 1st EOF"); }
| 
  { info("before 2nd choice"); }
  bp_v()
  { info("passed bp_v()"); }
  bp_v$()
  { info("passed bp_v$()"); }
  bp_v_()
  { info("passed bp_v_()"); }
  bp_w()
  { info("passed bp_w()"); }
  bp_w_()
  { info("passed bp_w_()"); }
  bp_x()
  { info("passed bp_x()"); }
  bp_x_()
  { info("passed bp_x_()"); }
  bp_x__()
  { info("passed bp_x__()"); }
  bp_y()
  { info("passed bp_y()"); }
  bp_y_()
  { info("passed bp_y_()"); }
  bp_z_()
  { info("passed bp_z_()"); }
  bp_z__()
  { info("passed bp_z__()"); }
  bp_v_o() // for first test case
  { info("passed bp_v_o() 1"); }
  bp_v_o() // for second test case
  { info("passed bp_v_o() 2"); }
  bp_ui(21, true)
  { info("bp_ui(21, true)"); }
  bp_ui$(22, false)
  { info("passed bp_ui$(22, false)"); }
  bp_s()
  { info("passed bp_s()"); }
  bp_s$()
  { info("passed bp_s$()"); }
  bp_sa()
  { info("passed bp_s()"); }
  bp_v1()
  { info("passed bp_v1()"); }
  bp_v2()
  { info("passed bp_v2()"); }
  bp_v3()
  { info("passed bp_v3()"); }
  bp_s1()
  { info("passed bp_s1()"); }
  bp_s2()
  { info("passed bp_s2()"); }
  bp_s3()
  { info("passed bp_s3()"); }
  bp_c()
  { info("passed bp_c()"); }
  bp_ca()
  { info("passed bp_ca()"); }
  bp_h()
  { info("passed bp_h()"); }
  bp_haa()
  { info("passed bp_haa()"); }
  bp_l()
  { info("passed bp_l()"); }
  bp_laa$()
  { info("passed bp_laa$()"); }
  bp_d()
  { info("passed bp_d()"); }
  bp_da()
  { info("passed bp_da()"); }
  bp_f()
  { info("passed bp_s()"); }
  bp_fa$()
  { info("passed bp_fa$()"); }
  bp_al$()
  { info("passed bp_al$()"); }
  bp_jual()
  { info("passed bp_jual()"); }
  bp_hm(jual)
  { info("passed bp_hm(jual)"); }
  < EOF >
  { info("after 2nd EOF"); }
|
  { info("before 3rd choice"); }
  ";" // does not need WS after!
  { info("passed ;"); }
  bp_tu_a()
  { info("passed bp_tu_a()"); }
  bp_acc()
  { info("passed bp_acc()"); }
  bp_DoubleThrows(1)
  { info("passed bp_DoubleThrows(1)"); }
  try {
    bp_DoubleThrows(0)
    { info("passed bp_DoubleThrows(0)"); }
  } catch (IllegalStateException ise) {
    { info("caught IDE in bp_DoubleThrows(0)"); }
  }
  jcp_DoubleThrows(1)
  { info("passed jcp_DoubleThrows(1)"); }
  try {
    jcp_DoubleThrows(0)
    { info("passed jcp_DoubleThrows(0)"); }
  } catch (IllegalStateException ise) {
    { info("caught IDE in jcp_DoubleThrows(0)"); }
  }
  skipButBuild()
  { info("passed skipButBuild()"); }
  eatNextToken()
  { info("passed eatNextToken()"); }
  < EOF >
  { info("after 3rd EOF"); }
|
  { info("before 4th choice"); }
  "," // does not need WS after!
  { info("passed ,"); }
  expch_a()
  { info("passed expch_a()"); }
  expch_b()
  { info("passed expch_b()"); }
  expch_c(-1, 9)
  { info("passed expch_c(-1, 9)"); }
  expch_c(0, 9)
  { info("passed expch_c(0, 9)"); }
  expch_c(1, 8)
  { info("passed expch_c(1, 8)"); }
  expch_c(1, 2)
  { info("passed expch_c(1, 2)"); }
  expch_c(1, 3)
  { info("passed expch_c(1, 3)"); }
  expch_c(-2, 9)
  { info("passed expch_c(-2, 9)"); }
  { info("after 4th choice"); }
|
  { info("before 5th choice"); }
  "." // does not need WS after!
  { info("passed ."); }
  expch_em_lxac()
  { info("passed expch_em_lxac(1)"); }
  expch_em_lxac()
  { info("passed expch_em_lxac(2)"); }
  expch_em_lxac()
  { info("passed expch_em_lxac(3)"); }
  expch_em_lxac()
  { info("passed expch_em_lxac(4)"); }
  expch_wosn_a()
  { info("passed expch_wosn_a(1)"); }
  expch_wosn_a()
  { info("passed expch_wosn_a(2)"); }
  expch_wosn_b()
  { info("passed expch_wosn_b(1)"); }
  expch_wosn_b()
  { info("passed expch_wosn_b(2)"); }
  expch_wnsn()
  { info("passed expch_wnsn(1)"); }
  expch_wnsn()
  { info("passed expch_wnsn(2)"); }
  expch_2ch()
  { info("passed expch_2ch()"); }
  { info("after 5th choice"); }
}

void bp_v() :
{}
{
  < ID >
}

void bp_v$() ! :
{}
{
  < ID >
}

void bp_v_() :
{}
{
  < ID > !
}

void bp_w() :
{}
{
  < NUM_2$ >
}

void bp_w_() :
{}
{
  < NUM_2$ > !
}

void bp_x() :
{}
{
  bp_v()
}

void bp_x_() :
{}
{
  bp_v() !
}

void bp_x__() :
{}
{
  bp_v$()
  bp_v$() !
  ( bp_v$() ! )
}

void bp_y() :
{}
{
  // Non StringLiteral Named RegularExpression
  < Y : ":y" >
  // StringLiteral RegularExpression
  ":"
}

void bp_y_() :
{}
{
  // StringLiteral RegularExpression
  "!"
  // Non StringLiteral UNNamed RegularExpression
  < "y!" > !
}

void bp_z_() :
{}
{
  bp_y() !
}

void bp_z__() :
{}
{
  bp_y_()
}

void bp_v_o() :
{}
  {
    // weird syntaxes discussed in issue #86
    // "bar" is matched by < ID >
    // "_bar _bar" not matched by this ExpansionChoices
    (
      LOOKAHEAD(2)
      (
        "_foo"
      |
        { /* empty lexical action */ }
      )
      "_bar" < ID >
      { info("- A1"); }
    | 
      "_bar" "_bar"
      { info("- A2"); }
    )
    // "_foo _bar id" not matched by this ExpansionChoices
    (
      LOOKAHEAD(2)
      (
        // JJ compile warning: choice (of empty token) always taken before following choices
        { /* empty lexical action */ }
      |
        "_foo"
      )
      "_bar" < ID >
      { info("- B1"); }
    | 
      "_bar" "_bar"
      { info("- B2"); }
    )
    { info("- C"); }
  }

// JavaCC does not accept final (but should TODO report bug#)
/*
final protected void bp_fov() :
{}
{
  < ID >
}

final protected void bp_fov$() ! :
{}
{
  < ID >
}
*/

int bp_i() :
{ Token tk = null; }
{
  tk = < ID >
  {
    return tk.image.length();
  }
}

void bp_i2() :
{ int i = 0; }
{
  i = bp_i()
}

public int bp_ui(final int i, boolean b) throws IllegalStateException, NullPointerException :
{ int j; }
{
  j = < ID >.kind // just for code coverage of RegularExpression() "."  < IDENTIFIER > in ExpansionUnit()
  {
    if (i == 0)
    {
      if (b) throw new IllegalStateException("with parameter");
      else throw new NullPointerException();
    }
    return i;
  }
}

public int bp_ui$(final int i, boolean b) throws IllegalStateException, NullPointerException ! :
{}
{
  < ID >
  {
    if (i == 0)
    {
    if (b) throw new IllegalStateException((String) null); // cast for ambiguity suppression
      else throw new NullPointerException();
    }
    return i - 1;
  }
}

protected String bp_s() :
{ Token tk; }
{
  tk = < ID >
  {
    return tk.image;
  }
}

protected java.lang.String bp_s$() ! :
{ Token tk; }
{
  tk = < ID >
  {
    return tk.image;
  }
}

protected String[] bp_sa() :
{ Token tk; }
{
  tk = < ID >
  {
    return new String[] { tk.image, null };
  }
}

void bp_v1() :
{ Token t = null; }
{
  bp_v()
  {
    return;
  }
}
  
void bp_v2() :
{ Token t = null; }
{
  bp_v$()
  {
    return;
  }
}
  
void bp_v3() :
{ Token t1 = null, t2 = null; }
{
  bp_v()
  bp_v$()
  {
    return;
  }
}
  
String bp_s1() :
{ String s = null; }
{
  s = bp_s()
  {
    return s;
  }
}
  
String bp_s2() :
{ java.lang.String s = null; }
{
  s = bp_s$()
  {
    return s;
  }
}
  
String bp_s3() :
{ String s1 = null, s2 = null; }
{
  s1 = bp_s()
  s2 = bp_s$()
  {
    return s1 + s2;
  }
}
  
// JavaCC handles correctly bad Modifiers combination; should JTB ?
/*
public protected boolean bp_uo() :
{}
{
  < ID >
  {
    return false;
  }
}
*/

char bp_c() :
{}
{
  < cdID$ >
  {
    return '0';
  }
}

char[] bp_ca() :
{}
{
  < cdID$ >
  {
    return new char[] { '0', '1' };
  }
}

short bp_h() :
{}
{
  (    < ID >
  )
  {
    return 0;
  }
}

short[][] bp_haa() :
{}
{
  < ID >
  {
    return new short[][] { { 0, 1 }, { -2, +3} };
  }
}

long bp_l() :
{}
{
  < ID >
  {
    return 0L;
  }
}

long[][] bp_laa$() ! :
{}
{
  < ID >
  {
    return new long[2][];
  }
}

double bp_d() :
{}
{
  < cdID$ >
  {
    return 0.0;
  }
}

double[] bp_da() :
{}
{
  < cdID$ >
  {
    return new double[] { 0.1e-234, -2.E+303, Double.NaN, Double.NEGATIVE_INFINITY, Double.MIN_NORMAL };
  }
}

float bp_f() :
{}
{
  < efID >
  {
    return -123465789.98764321F;
  }
}

float[] bp_fa$() ! :
{}
{
  < efID >
  {
    return new float[] { -23.E-40F, .12e+30F, Float.MAX_VALUE, Float.POSITIVE_INFINITY };
  }
}

ArrayList < Float > bp_al$() !:
{
  ArrayList< Float > al = new ArrayList<>();
  java.util.ArrayList < Float > jual;
}
{
  < abID >
  {
    al.add(- 23.E-40F);
    jual = new java.util.ArrayList<>(al);
    jual.add(.12e+30F);
    return jual;
  }
}

java.util.ArrayList < Float > bp_jual() :
{
  ArrayList< Float > al = new ArrayList<>();
  java.util.ArrayList < Float > jual;
}
{
  < ID >
  {
    al.add(- 23.E-40F);
    jual = new java.util.ArrayList<>(al);
    jual.add(.12e+30F);
    return jual;
  }
}

java.util.HashMap < String, Float > bp_hm(final java.util.ArrayList < Float > jual) :
{
  java.util.HashMap < String, Float > hm = new java.util.HashMap<> ();
}
{
  < ID >
  {
    hm.put("nine", jual == null ? 9.9F : jual.get(9));
    return hm;
  }
}

Tuple <? extends java.lang.CharSequence,? super CharSequence,? > bp_tu_a() :
{
  Tuple tu;
}
{
  < ID >
  (
    skipButBuild()
    skipButBuild() !
    eatNextToken()
    eatNextToken() !
    jcp_ubar()
    jcp_ubar() !
    jcp_ubar$()
    jcp_ubar$() !
  )
  bp_v()
  bp_v() !
  bp_v$()
  bp_v$() !
  {
    final Tuple < ? super java.lang.CharSequence, ?, Object [ ] > tv = new Tuple('c', 1, new Object [ 1 ]);
    tu = new Tuple("a", 'c', true);
    return tu;
  }
}

void bp_acc() :
{}
{
  < ID >
  { info("- bp_acc after ID"); }
  [ "xyz" { info("- bp_acc after xyz"); } ]
  ( LOOKAHEAD(2) bp_i() { info("- bp_acc after bp_i"); } )*
    (
      bp_v() { info("- bp_acc after bp_v"); }
    |
      (
        bp_w() { info("- bp_acc after bp_w"); }
        bp_x() { info("- bp_acc after bp_x"); }
      )
    )
}

void bp_DoubleThrows(final int i) throws IllegalStateException, NullPointerException :
{
  Token tk = null;
}
{
  < cdID$ >
  {
    if (tk != null) throw new NullPointerException();
    else if (i == 0) throw new IllegalStateException();
  }
}

FGclass1 bp_class1() :
{}
{
  < ID >
  { return new FGclass1(); }
}

FGclass2 bp_class2$() ! :
{}
{
  < ID >
  { return new FGclass2(); }
}

JAVACODE void jcp_DoubleThrows(final int i) throws IllegalStateException, NullPointerException %
{
  // eat a token
  Token tk = getNextToken();
  {
    if (tk == null) throw new NullPointerException();
    else if (i == 0) throw new IllegalStateException();
  }
}

JAVACODE void skipButBuild() throws ParseException %
{
  // eat a token
  Token tk = getNextToken();
  // some fancy Java statements, for completing code coverage
  {
    int [ ] ai = { 0 , 0 } ;
    for (final int i : ai)
    {
      switch (i)
      {
      }
      switch (i)
      {
        default : break;
      }
      switch (i)
      {
        case 0 :
        { /* empty block */ }
        {
          break;
        }
        case 1 :
      }
    }
    label:
    {
      for (;;) break label;
    }
    return;

    class dummyClass
    {
      int dummyMethod() throws ParseException
      {
        throw new ParseException();
      }
    }
    try
    {
      new dummyClass().dummyMethod();
    }
    catch (Exception e)
    {
      synchronized ("x")
      {
        int j = 0;
      }
    }
    finally
    {
      label : 
      do
      {
        char c = 'c';
      }
      while (false);
    }
  }
}

JAVACODE void eatNextToken()
{
  // eat a token
  Token tk = getNextToken();
}

JAVACODE Token eatAndReturnNextToken()
{
  // eat and return a token
  return getNextToken();
}

/*
 * ------------------------
 * dummy productions, some not used, for code coverage
 * expansion choices with different levels and different lookaheads
 * ------------------------
 */

void expch_a() :
{}
{
  LOOKAHEAD(2)
  "!" < ID > { info("- passed ! ID"); }
| "!abc" { info("- passed ! abc"); }
}

void expch_b() :
{}
{
  (
    LOOKAHEAD(2, "?" < abID >)
    "?" < abID > { info("- passed ? abID"); }
  | "?abc" { info("- passed ? abc"); }
  )
}

void expch_c(final int i, final int j) :
{ global_i = i; global_j = j; }
{
  // amount, expansion and { expression } combinations
  (
    LOOKAHEAD(2)
    (
      LOOKAHEAD(< NUM_3_9 > "!NUM_3_9!")
      < NUM_3_9 > "!NUM_3_9!" { info("- passed expch_c NUM_3_9 !NUM_3_9!"); }
    | 
      < NUM_3_9 > < ID > { info("- passed expch_c NUM_3_9 ID"); }
    | 
      LOOKAHEAD({ global_i == 0 })
      < ID > "i==0" { info("- passed expch_c ID 0"); }
    | 
      LOOKAHEAD(< ID >, { global_i == 1 })
      (
        LOOKAHEAD(2, < ID > "i==1")
        < ID > "i==1" { info("- passed expch_c ID 1"); }
      )?
      (
        LOOKAHEAD(2, { global_j == 2 })
        < ID > "j==2" { info("- passed expch_c ID 2"); }
      )*
      (
        LOOKAHEAD(2, < ID > "j==3", { global_j == 3 })
        < ID > "j==3" { info("- passed expch_c ID 3"); }
      )+
    )
  | < ES > { info("- passed expch_c ES"); }
  | < NUM_3_9 > "*39*" { info("- passed expch_c NUM_3_9 *39*"); }
  )
}

void expch_em_lxac() : // empty_lexical_actions
{}
  {
    (
      LOOKAHEAD(":poi")
      ":poi"
    | LOOKAHEAD(":uyt")
      { /* empty lexical action, before a token */}
      ":uyt"
    | ":rez"
      { /* empty lexical action, after a token */}
    |
      { /* empty lexical action, no token */}
    )
    "/"
  }

void expch_wosn_a() !: // with_one_sub_node
{}
{
  LOOKAHEAD(2)
  ";abc"
| < ID > !
}

void expch_wosn_b() !: // with_one_sub_node
{}
{
  LOOKAHEAD(2, ";def")
  ";def" !
| < efID >
}

void expch_wnsn() : // with_no_sub_node
{}
{
  LOOKAHEAD(2, ";ghi1", { 1 == 1 })
  ";ghi1" ! ";x" !
| LOOKAHEAD(2, ";ghi2")
  ";ghi2" ! ";x" !
| LOOKAHEAD(2, { 2 == 2 })
  ";ghi3" ! ";x" !
| LOOKAHEAD(";ghi4", { 3 == 3 })
  ";ghi4" ! ";x" !
| LOOKAHEAD(";ghi5")
  ";ghi5" ! ";x" !
| LOOKAHEAD(2)
  ";ghi6" ! ";x" !
| < ID > ! ";x" !
| ( ";x" !
  | ";y" !
  | ";z" !
  )
| ( ";1" ! )
| ( LOOKAHEAD(2) ";2" ! )+
| ( LOOKAHEAD(2) ";3" ! )*
| ( LOOKAHEAD(2) ";4" ! )?
| [ LOOKAHEAD(2) ";5" ! ]
}

void expch_2ch() : // 2 choices in sequence
{}
{
(
  ",jkl"
| ",mno" !
)
(
  ",pqr" !
| ",stu"
)
}

void expch_bl_a() :
{}
{
  < NUM_3_9 > 
| { some_lexical_action(); }
}

void expch_bl_a$() :
{}
{
  < NUM_2$ >
| { some_lexical_action(); }
}

void expch_bl_b() :
{}
{
  // JJ compile warning: choice (of empty token) always taken before following choices
  { some_lexical_action(); }
  // JavaCC will not generate anything beyond here
| < NUM_3_9 >
}

void expch_bl_b$() :
{}
{
  // JJ compile warning: choice (of empty token) always taken before following choices
  { some_lexical_action(); }
  // JavaCC will not generate anything beyond here
| < NUM_2$ >
}

void expch_bl_c() :
{}
{
  LOOKAHEAD( { some_lookahead() } )
  { some_lexical_action(); }
|
  // JavaCC will generate this choice because of the previous LA
  < NUM_3_9 >
}

void expch_bl_c$() :
{}
{
  LOOKAHEAD( { some_lookahead() } )
  { some_lexical_action(); }
|
  // JavaCC will generate this choice because of the previous LA
  < NUM_2$ >
}

void expch_bl_d() :
{}
{
  LOOKAHEAD(2) 
  < A_BS_B > 
  { some_lexical_action(); }
|
  { some_lexical_action(); }
  < NUM_3_9 >
|
  < NUM_2$ >
  { some_lexical_action(); }
|
  { some_lexical_action(); }
  < A_BS_B > !
//|
//  // JavaCC raises an error for this: Expansion within "(...)?" can be matched by empty string.
//  [{ some_lexical_action(); }]
//|
//  // JavaCC raises an error for this: Expansion within "(...)?" can be matched by empty string.
//  ( { some_lexical_action(); } )?
//|
//  // JavaCC raises an error for this: Expansion within "(...)*" can be matched by empty string.
//  ( { some_lexical_action(); } )*
//|
//  // JavaCC raises an error for this: Expansion within "(...)+" can be matched by empty string.
//  ( { some_lexical_action(); } )+
|
  // only 1 block
  // JJ compile warning: choice (of empty token) always taken before following choices
  { boolean a = true; }
  // JavaCC will not generate anything beyond here
|
  // only 2 blocks
  { boolean b1 = true; }
  { boolean b2 = true; }
|
  // only 3 blocks
  { boolean c1 = true; }
  { boolean c2 = true; }
  { boolean c3 = true; }
|
  "$^$^"
}

void expch_eu_a() : // eu case 2 bracket & case 5 parentheses & eu case 1 ias crec
{}
{
  < abID >
| < ["="] > ! // JJ compile warning: Consider giving this non-string token a label for better error reporting
| < OP : ["+"] >
| "*1"
  ( < SC1 : ";1" >
  | < cdID$ >
  | < efID >
  )
  [ < SC2 : (";2") > !
// JJ compile warning: Encountered LOOKAHEAD(...) at a non-choice location.  This will be ignored.
//    LOOKAHEAD(2) // ExpansionUnit
    (
      LOOKAHEAD(2) // ExpansionUnit, used by JavaCC ("< abID >")
      // only if next ExpansionChoices is surrounded by ()
      // note: the choice conflict in (...)? construct at ...
      // Expansion nested within construct and expansion following construct
      // appears because the 'expansion following construct' is the last one (with "*5")
      ( < abID >
      | < "*2" >
      | "*3" !
      )
    )?
  ]
  ( < SC3 : (";3")+ > !
// JJ compile warning: Encountered LOOKAHEAD(...) at a non-choice location.  This will be ignored.
//    LOOKAHEAD(2) // ExpansionUnit
    (
      LOOKAHEAD(2) // ExpansionUnit, used by JavaCC ("< abID >")
      // only if next ExpansionChoices is surrounded by ()
      // note: the choice conflict in (...)? construct at ...
      // Expansion nested within construct and expansion following construct
      // appears because the 'expansion following construct' is the last one (with "*5")
      ( < abID >
      | < "*2" >
      | "*3" !
      )
    )?
  )?
  ( "*4"
    (
      LOOKAHEAD(2) // ExpansionUnit, used by JavaCC ("< abID >")
      // only if next ExpansionChoices is surrounded by ()
      // note: the choice conflict in (...)? construct at ...
      // Expansion nested within construct and expansion following construct
      // appears because the 'expansion following construct' is the last one (with "*5")
      ( < abID > !
      | < cdID$ >
      | < efID >
      )
    )*
  )*
  ( ( < "*5" > )?
    (
      LOOKAHEAD(2) // ExpansionUnit, used by JavaCC ("< abID >")
      // only if next ExpansionChoices is surrounded by ()
      // note: the choice conflict in (...)+ construct at ...
      // Expansion nested within construct and expansion following construct
      // appears because the 'expansion following construct' is itself (by the +)
      (
        < abID >
      | < "*6" > !
      | < SC4 : ( ";4" )+ >
      | < SC5 : ( ";5" ){7,8} > !
      | < SC6 : ( ";6" ){9} > !
      )
    )+
  )+
}

/*
 * ------------------------
 * dummy productions, not used, just for overall code coverage
 * expansion_units with lookaheads at different levels and different node creations
 * ------------------------
 */

void expun_a1() :
{}
{
  < ID >
  Identifier()
  (
    LOOKAHEAD({ true })
    < ID >
  | Identifier()
  )
  (
    LOOKAHEAD(< ID >)
    < ID >
  | Identifier()
  )
}

void expun_b1() :
{}
{
  < ID >
  Identifier()
  (
    LOOKAHEAD({ true })
    < ID >
  | Identifier()
  )
  eu_id_or_ident()
}

void expun_c1() :
{}
{
  < ID >
  Identifier()
  (
    LOOKAHEAD({ true })
    < ID >
  | Identifier()
  )
  eu_id_or_ident$()
}

void expun_d1() :
{}
{
  < ID >
  Identifier()
  (
    LOOKAHEAD({ true })
    < ID >
  | Identifier()
  )
  eu_id_or_ident() !
}

void expun_a2() :
{}
{
  < ID >
  Identifier()
  (
    LOOKAHEAD({ true })
    < ID >
  | Identifier()
    (
      LOOKAHEAD(< ID >)
      < ID >
    | Identifier()
    )
  )
}

void expun_b2() :
{}
{
  < ID >
  Identifier()
  (
    LOOKAHEAD({ true })
    < ID >
  | Identifier()
    eu_id_or_ident()
  )
}

void expun_c2() :
{}
{
  < ID >
  Identifier()
  (
    LOOKAHEAD({ true })
    < ID >
  | Identifier()
    eu_id_or_ident$()
  )
}

void expun_d2() :
{}
{
  < ID >
  Identifier()
  (
    LOOKAHEAD({ true })
    < ID >
  | Identifier()
    eu_id_or_ident() !
  )
}

void expun_a3() :
{}
{
  < ID > !
  Identifier() !
  (
    LOOKAHEAD({ true })
    < ID >
  | Identifier()
    eu_id_or_ident()
  )
}

void expun_b3() :
{}
{
  < ID > !
  Identifier() !
  (
    LOOKAHEAD({ true })
    < ID > !
  | Identifier()
    eu_id_or_ident()
  )
}

void expun_c3() :
{}
{
  < ID > !
  Identifier() !
  (
    LOOKAHEAD({ true })
    < ID >
  | Identifier() !
    eu_id_or_ident() !
  )
}

void expun_d3() :
{}
{
  < ID > !
  Identifier() !
  (
    LOOKAHEAD({ true })
    < ID > !
  | Identifier() !
    eu_id_or_ident() !
  )
}

/*
 * ------------------------
 * identifiers productions
 * ------------------------
 */

void eu_id_or_ident() :
{}
{
  LOOKAHEAD(< ID >)
  < ID >
| Identifier()
}
  

void eu_id_or_ident$() !:
{}
{
  LOOKAHEAD({ true })
  < ID >
| Identifier()
}
  

void Identifier() :
{}
{
  < A_BS_B >
| < ID >
}

/*
 * ------------------------
 * miscellaneous
 * ------------------------
 */

// check proper formatting by the plugin (spaces / newlines / ...)
int check_proper_formatting() :
{ int count = 0;}
{
    LOOKAHEAD( < ID > | < ES > )
  < ID > | < ES >
  {
    @SuppressWarnings("unused") boolean b = false;
    return ++count;
  }
  
}

/*
 * ---------------------------------------------------
 * Systematically built productions, for code coverage
 * ---------------------------------------------------
 */

/*
 * ---------------------------------------------------
 * ExCh f0 alone / no LoAh / 1 ExUn
 * ---------------------------------------------------
 */

void f0_eu1_be() : // Block empty
{}
{
  { /* empty block */ }
}

void f0_eu1_b1() : // Block (not empty)
{}
{
  { String s = "f0_eu1_b1"; }
}

String f0_eu1_b2() : // Block (not empty)
{}
{
  { return "f0_eu1_b2"; }
}

void f0_eu1_ias1() : // IdentifierAsString
{}
{
  f0_eu1_be()
}

void f0_eu1_ias2() : // IdentifierAsString
{}
{
  try { f0_eu1_b1() } finally  { /* swallowed */ }
}

void f0_eu2_all1() : // all types of LA in ExpansionUnit for JJFileAnnotator
{ int k; String im; }
{
  LOOKAHEAD(0) // Expansion, no warning but seems then ignored by JavaCC
// JJ compile warning: Encountered LOOKAHEAD(...) at a non-choice location.  This will be ignored.
  LOOKAHEAD(1) // Expansion
  [
    LOOKAHEAD(2) // ExpansionUnit, used by JavaCC (".")
    k = ".".kind !
  ]
  [
    LOOKAHEAD(2) // ExpansionUnit, used by JavaCC (";")
    im = ";".image
  ]
//  LOOKAHEAD(0) // ExpansionUnit, no warning but seems then ignored by JavaCC
// JJ compile warning: Encountered LOOKAHEAD(...) at a non-choice location.  This will be ignored.
  LOOKAHEAD(1) // ExpansionUnit
  f0_eu1_b1()
  ( ";; " ( ";;; " ";;;; " ) )
  ( "!! " ! ( "!!! " ! "!!!! " ! ) )
  // "%ctbu?no" cannot be used as a more general regexpr is already defined
  (
     LOOKAHEAD("%ctbu?no***") // ExpansionUnit, used by JavaCC ("%ctbu?no***")
     "%ctbu?no***" !
     im = < A_BS_B >.image !
  )+
  // "%ctbu?yes" can be used as the same general regexpr is already defined
  (
     LOOKAHEAD(1, "%ctbu?yes") // ExpansionUnit, used by JavaCC ("%ctbu?yes")
     "%ctbu?yes" !
     < NUM_3_9 >
  )*
  (
     LOOKAHEAD(":") // ExpansionUnit, used by JavaCC (":")
     (
        LOOKAHEAD(2) // Expansion, used by JavaCC (":")
        ":" < NOT_BUILT >
     |
       ":" < ES >
     )
  )?
  try
  {
    f0_eu1_peias2()
    try { expch_a() | expch_b() }
    finally { /* nothing */ }
    try { ( expch_2ch() | expch_bl_a() ) }
    catch (final Exception e) { /* swallowed */ }
  }
  catch (ParseException pe) { pe = null; }
  catch (final Exception e) { /* swallowed */ }
}

void f0_eu2_all1$() ! : // all types of LA in ExpansionUnit for JavaCCPrinter (same as previous)
{ int k; String im; }
{
  LOOKAHEAD(0) // Expansion, no warning but seems then ignored by JavaCC
// JJ compile warning: Encountered LOOKAHEAD(...) at a non-choice location.  This will be ignored.
  LOOKAHEAD(1) // Expansion
  [
    LOOKAHEAD(2) // ExpansionUnit, used by JavaCC (".")
    k = ".".kind !
  ]
  [
    LOOKAHEAD(2) // ExpansionUnit, used by JavaCC (";")
    im = ";".image
  ]
//  LOOKAHEAD(0) // ExpansionUnit, no warning but seems then ignored by JavaCC
// JJ compile warning: Encountered LOOKAHEAD(...) at a non-choice location.  This will be ignored.
  LOOKAHEAD(1) // ExpansionUnit
  f0_eu1_b1()
  ( ";; " ( ";;; " ";;;; " ) )
  ( "!! " ! ( "!!! " ! "!!!! " ! ) )
  // "%ctbu?no" cannot be used as a more general regexpr is already defined
  (
     LOOKAHEAD("%ctbu?no***") // ExpansionUnit, used by JavaCC ("%ctbu?no***")
     "%ctbu?no***" !
     im = < A_BS_B >.image !
  )+
  // "%ctbu?yes" can be used as the same general regexpr is already defined
  (
     LOOKAHEAD(1, "%ctbu?yes") // ExpansionUnit, used by JavaCC ("%ctbu?yes")
     "%ctbu?yes" !
     < NUM_3_9 >
  )*
  (
     LOOKAHEAD(":") // ExpansionUnit, used by JavaCC (":")
     (
        LOOKAHEAD(2) // Expansion, used by JavaCC (":")
        ":" < NOT_BUILT >
     |
       ":" < ES >
     )
  )?
  try
  {
    f0_eu1_peias2()
    try { expch_a() | expch_b() }
    finally { /* nothing */ }
    try { ( expch_2ch() | expch_bl_a() ) }
    catch (final Exception e) { /* swallowed */ }
  }
  catch (ParseException pe) { pe = null; }
  catch (final Exception e) { /* swallowed */ }
}

void f0_eu1_jc() : // Javacode
{}
{
  eatNextToken()
}

void f0_eu1_peias1() : // PrimaryExpression+IdentifierAsString
{ String s; }
{
  s = f0_eu1_b2()
}

String f0_eu1_peias2() : // PrimaryExpression+IdentifierAsString
{ String s; }
{
  s = f0_eu1_b2()
  { return "f0_eu1_peias / " + s; }
}

void f0_eu1_pejc1() : // PrimaryExpression+Javacode
{ Token tk = null; }
{
  tk = eatAndReturnNextToken()
}

String f0_eu1_pejc2() : // PrimaryExpression+Javacode
{ Token tk = null; }
{
  tk = eatAndReturnNextToken()
  { return "f0_eu1_pejc / " + tk.image; }
}

void f0_eu1_resl1() : // RegularExpression StringLiteral
{}
{
  "!"
}

void f0_eu1_resl2() : // RegularExpression StringLiteral
{}
{
  < resl2 : "!x" >
}

void f0_eu1_resl3() : // RegularExpression IdentifierAsString
{}
{
  < resl3 : < resl2 > >
}

void f0_eu1_recrec1() : // RegularExpression ComplexRegularExpressionChoices
{}
{
  // JJ compile warning: Regular Expression choice : efID can never be matched as : recrec1
  // looks like a simple RegularExpression (< IdentifierAsString >)
  // cannot be used alone in a ComplexRegularExpressionUnit, but can be used if not alone, see next production
  < recrec1 :
    < abID > < ID >
  | < efID >
  >
}

void f0_eu1_recrec2() : // RegularExpression ComplexRegularExpressionChoices
{}
{
  < /*#*/ recrec2 : // JavaCC does not accept here a private regular expression
    "!"
  | < resl2 > // JJ compile warning: Regular Expression choice : resl2 can never be matched as : recrec2
  | < resl3 > // JJ compile warning: Regular Expression choice : resl3 can never be matched as : recrec2
  | < efID > // JJ compile warning: Regular Expression choice : efID can never be matched as : recrec2
  | ("#1")
  |
    (
      ("#2")? "#3"
    |
      (
        ("#4")* "#5"
      | ("#6")+
      )
    )
  |
    ( "#7" < A_BS_B > ) // however, this looks to be accepted by JavaCC
    (
      "#8"
    | < SYN_ESC > // and this one too
    )
  >
}

void f0_eu1_recrec3() : // RegularExpression ComplexRegularExpressionChoices
{}
{
  < recrec3 :
    "'"
  | < recrec1 > // JJ compile warning: Regular Expression choice : efID can never be matched as : recrec3
  | < recrec2 > // JJ compile warning: Regular Expression choice : efID can never be matched as : recrec3
                // JJ compile warning: Regular Expression choice : resl3 can never be matched as : recrec3
                // JJ compile warning: Regular Expression choice : resl2 can never be matched as : recrec3
//  | < EOF > // JavaCC does not accept EOF here
  >
}

void f0_eu1_retk() : // RegularExpression Token
{}
{
  < cdID$ >
}

void f0_eu1_reeof() : // RegularExpression EOF
{}
{
  < EOF >
}

// voir comment composer les br avec les ExCh

//void f0_eu1_br_ias1() : // bracketed ExCh IdAsStr
//{}
//{
//  [ f0_eu1_be() ] // JJ compile error: Expansion within "(...)?" can be matched by empty string.
//}
//
//void f0_eu1_br_ias2() : // bracketed ExCh IdAsStr
//{}
//{
//  [ f0_eu1_b() ] // JJ compile error: Expansion within "(...)?" can be matched by empty string.
//}
//
//void f0_eu1_br_ias3() : // bracketed ExCh IdAsStr
//{}
//{
//  [ f0_eu1_br_jc() ] // JJ compile error: Expansion within "(...)?" can be matched by empty string.
//}
//
//void f0_eu1_br_ias4() : // bracketed ExCh IdAsStr
//{}
//{
//  [ f0_eu1_br_resl() ] // JJ compile error: Expansion within "(...)?" can be matched by empty string.
//}
//
//void f0_eu1_br_jc() : // bracketed ExCh Javacode
//{}
//{
//  [ eatNextToken() ]
//}
//
//void f0_eu1_br_resl() : // bracketed RegExp StrLit
//{}
//{
//  [ ":/" ]
//}
//
//void f0_eu1_br_retk() : // bracketed RegExp Token
//{}
//{
//  [ < abID > ]
//}
//
//void f0_eu1_br_reeof() : // bracketed RegExp EOF
//{}
//{
//  [ < EOF > ]
//}

// voir comment composer les tcf avec les ExCh

//void f0_eu1_tcf_be() : // block empty
//{}
//{
//  try { { /* empty block */ } }
//  catch (Exception ex) { /* nothing */ }
//  finally { /* nothing */ }
//}
//
//void f0_eu1_tcf_b() : // block not empty
//{ int[] ai; }
//{
//  try { { ai = new int[] { 0, 1 }; } }
//  catch (Exception ex) { ai = new int[2]; }
//  finally { ai = null; }
//}

/*
 * ---------------------------------------------------
 * ExCh f0 alone / with LoAh / 2 ExUn
 * ---------------------------------------------------
 */

void f0_laeu2_be() : // Block empty
{}
{
  // JJ compile warning: LA in non choice location, ignored
  LOOKAHEAD(1)
  { /* empty block */ }
}

void f0_laeu2_b1() : // Block (not empty)
{}
{
  // JJ compile warning: LA in non choice location, ignored
  LOOKAHEAD(1) 
  { String s = "f0_eu1_b1"; }
}

void f0_laeu2_ias1() : // IdentifierAsString
{}
{
  // JJ compile warning: LA in non choice location, ignored; TESTCASE for annotator case 0 ExpansionUnit
  LOOKAHEAD(1) 
  f0_eu1_be()
}

void f0_laeu2_ias2() : // IdentifierAsString
{}
{
  // JJ compile warning: LA in non choice location, ignored; TESTCASE for annotator case 0 ExpansionUnit
  LOOKAHEAD(1) 
  f0_eu1_b1()
}

void f0_laeu2_jc() : // Javacode
{}
{
  // JJ compile warning: LA in non choice location, ignored; TESTCASE for annotator case 0 ExpansionUnit
  LOOKAHEAD(1) 
  eatNextToken()
}
