/* Generated by JTB 1.5.1 */
package grammars.a.sgvis;

import grammars.a.sgtree.*;

/**
 * Provides default methods which visit each node in the tree in depth-first order.<br>
 * In your "Vis2" visitors extend this class and override part or all of these methods.
 *
 * @param <R> - The return type parameter
 * @param <A> - The argument 0 type parameter
 */
public class DepthFirstVis2Visitor<R, A> implements IVis2Visitor<R, A> {

  /** The depth level (0, 1, ...) */
  int depthLevel = 0;

  /*
   * Base nodes classes visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link NodeChoice} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument 0
   * @param argu1 - the user argument 1
   * @param argu2 - the user argument 2
   * @return the user return information
   */
  @Override
  public R visit(final NodeChoice n, final A argu, final int[] argu1, final short... argu2) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    ++depthLevel;
    final R nRes = n.choice.accept(this, argu, argu1, argu2);
    --depthLevel;
    return nRes;
  }

  /**
   * Visits a {@link NodeList} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument 0
   * @param argu1 - the user argument 1
   * @param argu2 - the user argument 2
   * @return the user return information
   */
  @Override
  public R visit(final NodeList n, final A argu, final int[] argu1, final short... argu2) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    for (INode e : n.nodes) {
      ++depthLevel;
      @SuppressWarnings("unused")
      final R sRes = e.accept(this, argu, argu1, argu2);
      --depthLevel;
    }
    return nRes;
  }

  /**
   * Visits a {@link NodeListOptional} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument 0
   * @param argu1 - the user argument 1
   * @param argu2 - the user argument 2
   * @return the user return information
   */
  @Override
  public R visit(final NodeListOptional n, final A argu, final int[] argu1, final short... argu2) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    if (n.present()) {
      R nRes = null;
      for (INode e : n.nodes) {
        ++depthLevel;
        @SuppressWarnings("unused")
        R sRes = e.accept(this, argu, argu1, argu2);
        --depthLevel;
      }
      return nRes;
    }
    return null;
  }

  /**
   * Visits a {@link NodeOptional} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument 0
   * @param argu1 - the user argument 1
   * @param argu2 - the user argument 2
   * @return the user return information
   */
  @Override
  public R visit(final NodeOptional n, final A argu, final int[] argu1, final short... argu2) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    if (n.present()) {
      ++depthLevel;
      final R nRes = n.node.accept(this, argu, argu1, argu2);
      --depthLevel;
      return nRes;
    }
    return null;
  }

  /**
   * Visits a {@link NodeSequence} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument 0
   * @param argu1 - the user argument 1
   * @param argu2 - the user argument 2
   * @return the user return information
   */
  @Override
  public R visit(final NodeSequence n, final A argu, final int[] argu1, final short... argu2) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    for (INode e : n.nodes) {
      ++depthLevel;
      @SuppressWarnings("unused")
      R subRet = e.accept(this, argu, argu1, argu2);
      --depthLevel;
    }
    return nRes;
  }

  /**
   * Visits a {@link NodeToken} node.
   *
   * @param n - the node to visit
   * @param argu - the user argument 0
   * @param argu1 - the user argument 1
   * @param argu2 - the user argument 2
   * @return the user return information
   */
  @Override
  public R visit(final NodeToken n, @SuppressWarnings("unused") final A argu, @SuppressWarnings("unused") final int[] argu1, @SuppressWarnings("unused") final short... argu2) {
    /* You have to adapt which data is returned (result variables below are just examples) */
    R nRes = null;
    @SuppressWarnings("unused")
    final String tkIm = n.tokenImage;
    return nRes;
  }

  /*
   * User grammar generated visit methods (to be overridden if necessary)
   */

  /**
   * Visits a {@link ASTclassDeclaration123} node, whose children are the following :
   * <p>
   * nodeToken -> "class"<br>
   * className -> className()<br>
   * nodeToken1 -> "{"<br>
   * nodeListOptional -> ( %0 method()<br>
   * ................ .. | %1 instruction() )*<br>
   * nodeToken2 -> "}"<br>
   * nodeToken3 -> "."<br>
   * jc_0 -> jc_0()<br>
   * nodeToken4 -> < EOF ><br>
   * s: 102044286<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument 0
   * @param argu1 - the user argument 1
   * @param argu2 - the user argument 2
   * @return the user return information
   */
  @Override
  public R visit(final ASTclassDeclaration123 n, final A argu, final int[] argu1, final short... argu2) {
    R nRes = null;
    // nodeToken -> "class"
    final NodeToken n0 = n.nodeToken;
    ++depthLevel;
    nRes = n0.accept(this, argu, argu1, argu2);
    --depthLevel;
    // className -> className()
    final ASTclassName123 n1 = n.className;
    ++depthLevel;
    nRes = n1.accept(this, argu, argu1, argu2);
    --depthLevel;
    // nodeToken1 -> "{"
    final NodeToken n2 = n.nodeToken1;
    ++depthLevel;
    nRes = n2.accept(this, argu, argu1, argu2);
    --depthLevel;
    // nodeListOptional -> ( %0 method()
    // ................ .. | %1 instruction() )*
    final NodeListOptional n3 = n.nodeListOptional;
    if (n3.present()) {
      for (int i = 0; i < n3.size(); i++) {
        final INode nloeai = n3.elementAt(i);
        final NodeChoice nch = (NodeChoice) nloeai;
        final INode ich = nch.choice;
        switch (nch.which) {
          case 0:
            //%0 method()
            ++depthLevel;
            nRes = ich.accept(this, argu, argu1, argu2);
            --depthLevel;
            break;
          case 1:
            //%1 instruction()
            ++depthLevel;
            nRes = ich.accept(this, argu, argu1, argu2);
            --depthLevel;
            break;
          default:
            // should not occur !!!
            throw new ShouldNotOccurException(nch);
        }
      }
    }
    // nodeToken2 -> "}"
    final NodeToken n4 = n.nodeToken2;
    ++depthLevel;
    nRes = n4.accept(this, argu, argu1, argu2);
    --depthLevel;
    // nodeToken3 -> "."
    final NodeToken n5 = n.nodeToken3;
    ++depthLevel;
    nRes = n5.accept(this, argu, argu1, argu2);
    --depthLevel;
    // jc_0 -> jc_0()
    final ASTjc_0123 n6 = n.jc_0;
    ++depthLevel;
    nRes = n6.accept(this, argu, argu1, argu2);
    --depthLevel;
    // nodeToken4 -> < EOF >
    final NodeToken n7 = n.nodeToken4;
    ++depthLevel;
    nRes = n7.accept(this, argu, argu1, argu2);
    --depthLevel;
    return nRes;
  }

  /**
   * Visits a {@link ASTclassName123} node, whose child is the following :
   * <p>
   * nodeToken -> < ID ><br>
   * s: 24392035<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument 0
   * @param argu1 - the user argument 1
   * @param argu2 - the user argument 2
   * @return the user return information
   */
  @Override
  public R visit(final ASTclassName123 n, final A argu, final int[] argu1, final short... argu2) {
    R nRes = null;
    // nodeToken -> < ID >
    final NodeToken n0 = n.nodeToken;
    ++depthLevel;
    nRes = n0.accept(this, argu, argu1, argu2);
    --depthLevel;
    return nRes;
  }

  /**
   * Visits a {@link ASTmethod123} node, whose children are the following :
   * <p>
   * methodName -> methodName()<br>
   * nodeToken -> "("<br>
   * nodeList -> ( instruction() )+<br>
   * nodeToken1 -> ")"<br>
   * s: -5715686<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument 0
   * @param argu1 - the user argument 1
   * @param argu2 - the user argument 2
   * @return the user return information
   */
  @Override
  public R visit(final ASTmethod123 n, final A argu, final int[] argu1, final short... argu2) {
    R nRes = null;
    // methodName -> methodName()
    final ASTmethodName123 n0 = n.methodName;
    ++depthLevel;
    nRes = n0.accept(this, argu, argu1, argu2);
    --depthLevel;
    // nodeToken -> "("
    final NodeToken n1 = n.nodeToken;
    ++depthLevel;
    nRes = n1.accept(this, argu, argu1, argu2);
    --depthLevel;
    // nodeList -> ( instruction() )+
    final NodeList n2 = n.nodeList;
    for (int i = 0; i < n2.size(); i++) {
      final INode lsteai = n2.elementAt(i);
      ++depthLevel;
      nRes = lsteai.accept(this, argu, argu1, argu2);
      --depthLevel;
    }
    // nodeToken1 -> ")"
    final NodeToken n3 = n.nodeToken1;
    ++depthLevel;
    nRes = n3.accept(this, argu, argu1, argu2);
    --depthLevel;
    return nRes;
  }

  /**
   * Visits a {@link ASTmethodName123} node, whose child is the following :
   * <p>
   * nodeToken -> < ID ><br>
   * s: 24392035<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument 0
   * @param argu1 - the user argument 1
   * @param argu2 - the user argument 2
   * @return the user return information
   */
  @Override
  public R visit(final ASTmethodName123 n, final A argu, final int[] argu1, final short... argu2) {
    R nRes = null;
    // nodeToken -> < ID >
    final NodeToken n0 = n.nodeToken;
    ++depthLevel;
    nRes = n0.accept(this, argu, argu1, argu2);
    --depthLevel;
    return nRes;
  }

  /**
   * Visits a {@link ASTinstruction123} node, whose child is the following :
   * <p>
   * nodeChoice -> . %0 #0 < ID > #1 ";"<br>
   * .......... .. | %1 ","<br>
   * s: -427851232<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument 0
   * @param argu1 - the user argument 1
   * @param argu2 - the user argument 2
   * @return the user return information
   */
  @Override
  public R visit(final ASTinstruction123 n, final A argu, final int[] argu1, final short... argu2) {
    R nRes = null;
    // nodeChoice -> . %0 #0 < ID > #1 ";"
    // .......... .. | %1 ","
    final NodeChoice nch = n.nodeChoice;
    final INode ich = nch.choice;
    switch (nch.which) {
      case 0:
        //%0 #0 < ID > #1 ";"
        final NodeSequence seq = (NodeSequence) ich;
        //#0 < ID >
        final INode nd = seq.elementAt(0);
        ++depthLevel;
        nRes = nd.accept(this, argu, argu1, argu2);
        --depthLevel;
        //#1 ";"
        final INode nd1 = seq.elementAt(1);
        ++depthLevel;
        nRes = nd1.accept(this, argu, argu1, argu2);
        --depthLevel;
        break;
      case 1:
        //%1 ","
        ++depthLevel;
        nRes = ich.accept(this, argu, argu1, argu2);
        --depthLevel;
        break;
      default:
        // should not occur !!!
        throw new ShouldNotOccurException(nch);
    }
    return nRes;
  }

  /**
   * Visits a {@link ASTbp_jual123} node, whose child is the following :
   * <p>
   * nodeToken -> < ID ><br>
   * s: 24392035<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument 0
   * @param argu1 - the user argument 1
   * @param argu2 - the user argument 2
   * @return the user return information
   */
  @Override
  public R visit(final ASTbp_jual123 n, final A argu, final int[] argu1, final short... argu2) {
    R nRes = null;
    // nodeToken -> < ID >
    final NodeToken n0 = n.nodeToken;
    ++depthLevel;
    nRes = n0.accept(this, argu, argu1, argu2);
    --depthLevel;
    return nRes;
  }

  /**
   * Visits a {@link ASTbp_hm123} node, whose child is the following :
   * <p>
   * nodeToken -> < ID ><br>
   * s: 24392035<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument 0
   * @param argu1 - the user argument 1
   * @param argu2 - the user argument 2
   * @return the user return information
   */
  @Override
  public R visit(final ASTbp_hm123 n, final A argu, final int[] argu1, final short... argu2) {
    R nRes = null;
    // nodeToken -> < ID >
    final NodeToken n0 = n.nodeToken;
    ++depthLevel;
    nRes = n0.accept(this, argu, argu1, argu2);
    --depthLevel;
    return nRes;
  }

  /**
   * Visits a {@link ASTjc_0123} node, with no child :
   * <p>
   * s: 0<br>
   *
   * @param n - the node to visit
   * @param argu - the user argument 0
   * @param argu1 - the user argument 1
   * @param argu2 - the user argument 2
   * @return the user return information
   */
  @SuppressWarnings("unused")
  @Override
  public R visit(final ASTjc_0123 n, final A argu, final int[] argu1, final short... argu2) {
    R nRes = null;
    /* empty node, nothing that can be generated so far */
    return nRes;
  }

  /**
   * Class handling a programmatic exception. Static for generic outer classes.
   */
  public static class ShouldNotOccurException extends RuntimeException {

    /** Default serialVersionUID */
    private static final long serialVersionUID = 1L;

    /**
     * Constructor with no message.
     */
    public ShouldNotOccurException() {
      super();
    }

    /**
     * Constructor which outputs a message.
     *
     * @param ch - a NodeChoice whose which value is invalid or lead to a fall-through
     */
    public ShouldNotOccurException(final NodeChoice ch) {
      super("Invalid switch value (" + ch.which + ") or fall-through");
    }

  }

}
